{
    "docs": [
        {
            "location": "/", 
            "text": "Python Landscape\n\n\nThis site focuses on providing details on the current Python landscape, providing\ndetails on the tech which creates the Python ecosystem. \n\n\n\n\n\n\nInterpreters, JITs \n Compilers\n\n\n\n\n\n\nGIL (Global Interpreter Lock) \n Alternatives\n\n\n\n\n\n\nIntegrating with C/C++", 
            "title": "Home"
        }, 
        {
            "location": "/#python-landscape", 
            "text": "This site focuses on providing details on the current Python landscape, providing\ndetails on the tech which creates the Python ecosystem.     Interpreters, JITs   Compilers    GIL (Global Interpreter Lock)   Alternatives    Integrating with C/C++", 
            "title": "Python Landscape"
        }, 
        {
            "location": "/interpreters_jits_and_compilers/", 
            "text": "Main\n\n\n\n\n\n\nCPython\n\n\n\n\n\n\nThe main implementation of Python. It's also interesting to note that the language semantics are mostly based on mimicking CPython for other languages. \n\n\n\n\n\n\nCuriosities:\n\n\n\n\nCPython has a \nGIL (Global Interpreter Lock)\n\n\n\n\n\n\n\n\n\n\n\n\nNumba\n\n\n\n\nNumba is an LLVM based JIT for CPython. It's numpy-aware and especially suited for algorithmic code. \n\n\n\n\n\n\n\n\nCython\n: \n\n\n\n\nA static compiler targeting CPython (with initial support for PyPy).\n\n\nCan compile Python code and mixed Cython/C/C++ code.\n\n\nCan also be used as a way to create bindings for existing C/C++ libraries.\n\n\nIt's predecessor was Pyrex (which is no longer actively maintaned).\n\n\nSupports Python 2.6 and 3.2 onwards.\n\n\n\n\n\n\n\n\nMicroPyton\n:\n\n\n\n\nMicro Python is an implementation of Python 3 optimized to run on a microcontroller.\n\n\n\n\n\n\n\n\nNuitka\n:\n\n\n\n\nNuitka targets compiling Python code using the libpython library (thus giving a very compatible support for Python code).\n\n\nAs it uses libpython, much of its code is still interpreted (and development is going into providing more optimizations).\n\n\nGiven its compliant nature, it can be used as a way for distributing Python code (as it's effectively a way to compile Python code).\n\n\n\n\n\n\n\n\nPyPy\n:\n\n\n\n\nPyPy is a Python interpreter with a builtin JIT which is able to grok Python code very well and make run it fast.\n\n\nIt can use \ncffi\n to interface with C code.\n\n\nIt also has a \nGIL (Global Interpreter Lock)\n, but is working in a branch to create a GIL-less version using STM (Software Transactional Memory).\n\n\n\n\n\n\n\n\nStackless Python\n:\n\n\n\n\nStackless Python is a CPython fork which has its own stack which can do context-switching to provide micro-threads and continuations.\n\n\nAlternatives to Stackless Python exist as libraries: \ngreenlet\n or \nasyncio\n can be used for that purpose.\n\n\n\n\n\n\n\n\nExperimental (in development)\n\n\n\n\n\n\nPyston\n:\n\n\n\n\nPyston is a Python implementation which has a builtin JIT (using LLVM). It's backed by Dropbox.\n\n\n\n\n\n\n\n\nIntegration with other languages\n\n\n\n\n\n\nJava: Jython\n\n\n\n\n\n\n.NET: IronPython\n\n\n\n\n\n\nJavaScript: pyjs\n\n\n\n\n\n\nJavaScript: RapydScript\n\n\n\n\n\n\nDeprecated/Unsupported libraries\n\n\nOver the years, other technologies were also created (and many resemble the ones above, although they're no longer actively mantained). \n\n\n\n\n\n\nPsyco\n\n\nPsyco was an optimizing JIT for CPython (developed from 2006-2010 by Armin Rigo) which was later abandoned because it was increasingly harder to maintain given its approach.\nAlso, its main developer went on to work on PyPy ;) \n\n\n\n\n\n\nShedskin\n\n\nDeveloped from 2008-2013 by Mark Dufour, it targeted translating pure (but implicitly typed) Python into C++.\n\n\n\n\n\n\nUnladen Swallow\n\n\nBack in 2009, Google sponsored a project which targeted integrating a JIT into CPython (using LLVM). \nThe project was later abandoned (although it had nice side effects, such as improving LLVM and providing a structure for performance tests).", 
            "title": "Interpreters, JITs & Compilers"
        }, 
        {
            "location": "/interpreters_jits_and_compilers/#main", 
            "text": "CPython    The main implementation of Python. It's also interesting to note that the language semantics are mostly based on mimicking CPython for other languages.     Curiosities:   CPython has a  GIL (Global Interpreter Lock)       Numba   Numba is an LLVM based JIT for CPython. It's numpy-aware and especially suited for algorithmic code.      Cython :    A static compiler targeting CPython (with initial support for PyPy).  Can compile Python code and mixed Cython/C/C++ code.  Can also be used as a way to create bindings for existing C/C++ libraries.  It's predecessor was Pyrex (which is no longer actively maintaned).  Supports Python 2.6 and 3.2 onwards.     MicroPyton :   Micro Python is an implementation of Python 3 optimized to run on a microcontroller.     Nuitka :   Nuitka targets compiling Python code using the libpython library (thus giving a very compatible support for Python code).  As it uses libpython, much of its code is still interpreted (and development is going into providing more optimizations).  Given its compliant nature, it can be used as a way for distributing Python code (as it's effectively a way to compile Python code).     PyPy :   PyPy is a Python interpreter with a builtin JIT which is able to grok Python code very well and make run it fast.  It can use  cffi  to interface with C code.  It also has a  GIL (Global Interpreter Lock) , but is working in a branch to create a GIL-less version using STM (Software Transactional Memory).     Stackless Python :   Stackless Python is a CPython fork which has its own stack which can do context-switching to provide micro-threads and continuations.  Alternatives to Stackless Python exist as libraries:  greenlet  or  asyncio  can be used for that purpose.", 
            "title": "Main"
        }, 
        {
            "location": "/interpreters_jits_and_compilers/#experimental-in-development", 
            "text": "Pyston :   Pyston is a Python implementation which has a builtin JIT (using LLVM). It's backed by Dropbox.", 
            "title": "Experimental (in development)"
        }, 
        {
            "location": "/interpreters_jits_and_compilers/#integration-with-other-languages", 
            "text": "Java: Jython    .NET: IronPython    JavaScript: pyjs    JavaScript: RapydScript", 
            "title": "Integration with other languages"
        }, 
        {
            "location": "/interpreters_jits_and_compilers/#deprecatedunsupported-libraries", 
            "text": "Over the years, other technologies were also created (and many resemble the ones above, although they're no longer actively mantained).     Psyco  Psyco was an optimizing JIT for CPython (developed from 2006-2010 by Armin Rigo) which was later abandoned because it was increasingly harder to maintain given its approach.\nAlso, its main developer went on to work on PyPy ;)     Shedskin  Developed from 2008-2013 by Mark Dufour, it targeted translating pure (but implicitly typed) Python into C++.    Unladen Swallow  Back in 2009, Google sponsored a project which targeted integrating a JIT into CPython (using LLVM). \nThe project was later abandoned (although it had nice side effects, such as improving LLVM and providing a structure for performance tests).", 
            "title": "Deprecated/Unsupported libraries"
        }, 
        {
            "location": "/gil/", 
            "text": "GIL (Global Interpreter Lock)\n\n\nThe GIL in CPython means that only one thread can be executing at a given time, meaning that it's usually fine using threads for I/O bound threads, but not for CPU bound threads (i.e.: things will not go faster with multiple threads).\n\n\nHowever, there are multiple solutions to that issue, which means it's usually not such a big issue (personally, I think that especially early on, Python succeeded not only because it's flexible with a nice syntax, but because the CPython implementation provided excellent interoperability with C):\n\n\nSo, some solutions you can use:\n\n\n\n\n\n\nExtension modules can release the GIL (so, it's possible to call code which does execute in parallel in CPython if you're willing to use the CPython C API, as long as it doesn't call back into the interpreter -- when the GIL has to be reaquired). \n\n\n\n\nSee: \nIntegrating with C/C++\n for more details.\n\n\n\n\n\n\n\n\nThe multiprocessing module provides a clean API for executing interpreters in multiple processes and synchronizing through queues and locks shared by multiple interpreters (although the memory has to be copied back and forth, which can make it unsuitable to use when dealing with huge amounts of data already in-memory).\n\n\n\n\nImplementation note: the multiprocessing module doesn't work the same way in all OSes (in Linux it'll fork the process and in Windows it'll create a new process from scratch, which means that it can have some caveats related to things such as open streams/handles, especially on Linux).\n\n\n\n\n\n\n\n\nNumpy\n + \nnumexpr\n: If you can represent your operations on numpy arrays, numexpr can take care of making it fast (even running on multiple threads).\n\n\n\n\n\n\nPyCuda\n: if you really need speed and your problem is suited for it, using the CUDA bindings can make it super-fast.\n\n\n\n\n\n\nParallelPython\n: if you really need to scale, ParallelPython provides a mechanism for parallel execution of python code for multiple cores and clusters.\n\n\n\n\n\n\nUse a different Python implementation (both \nJython\n and \nIronPython\n run without a GIL and the \nPyPy STM\n branch may also work for your use case).", 
            "title": "GIL (Global Interpreter Lock) & Alternatives"
        }, 
        {
            "location": "/gil/#gil-global-interpreter-lock", 
            "text": "The GIL in CPython means that only one thread can be executing at a given time, meaning that it's usually fine using threads for I/O bound threads, but not for CPU bound threads (i.e.: things will not go faster with multiple threads).  However, there are multiple solutions to that issue, which means it's usually not such a big issue (personally, I think that especially early on, Python succeeded not only because it's flexible with a nice syntax, but because the CPython implementation provided excellent interoperability with C):  So, some solutions you can use:    Extension modules can release the GIL (so, it's possible to call code which does execute in parallel in CPython if you're willing to use the CPython C API, as long as it doesn't call back into the interpreter -- when the GIL has to be reaquired).    See:  Integrating with C/C++  for more details.     The multiprocessing module provides a clean API for executing interpreters in multiple processes and synchronizing through queues and locks shared by multiple interpreters (although the memory has to be copied back and forth, which can make it unsuitable to use when dealing with huge amounts of data already in-memory).   Implementation note: the multiprocessing module doesn't work the same way in all OSes (in Linux it'll fork the process and in Windows it'll create a new process from scratch, which means that it can have some caveats related to things such as open streams/handles, especially on Linux).     Numpy  +  numexpr : If you can represent your operations on numpy arrays, numexpr can take care of making it fast (even running on multiple threads).    PyCuda : if you really need speed and your problem is suited for it, using the CUDA bindings can make it super-fast.    ParallelPython : if you really need to scale, ParallelPython provides a mechanism for parallel execution of python code for multiple cores and clusters.    Use a different Python implementation (both  Jython  and  IronPython  run without a GIL and the  PyPy STM  branch may also work for your use case).", 
            "title": "GIL (Global Interpreter Lock)"
        }, 
        {
            "location": "/integrating_c_and_cpp/", 
            "text": "CPython has a myriad of ways for integrating with C/C++:\n\n\nCreate bindings for other languages without needing a compilation step (pure-Python solutions)\n\n\n\n\n\n\ncffi\n: Provides a way to call compiled C from Python without any compilation step (also compatible -- and fast -- with PyPy).\n\n\n\n\n\n\nctypes\n: Builtin to Python it's a way to call C code from Python without any compilation step (also compatible with PyPy but slower than cffi).\n\n\n\n\n\n\nWrap C/C++ code and compile it to create bindings for existing C/C++ libraries.\n\n\n\n\n\n\nCython\n: can compile Python code and mixed Cython/C/C++ code and can be used to create bindings for existing C/C++ libraries (the most \"Pythonic\" of the listed solutions).\n\n\n\n\n\n\nSWIG\n: Provides a way to wrap C/C++ code and compile it creating bindings (not only for Python, but also a many other languages).\n\n\n\n\n\n\nPyCXX\n: Provides a way to wrap C/C++ code and compile it creating bindings for Python.\n\n\n\n\n\n\nBoost.Python\n: Provides a way to wrap C/C++ code and compile it creating bindings for Python.\n\n\n\n\n\n\nSIP\n: used by PyQt to wrap Qt.\n\n\n\n\n\n\nshiboken\n: Used by PySide to wrap Qt.", 
            "title": "Integrating with C/C++"
        }, 
        {
            "location": "/integrating_c_and_cpp/#create-bindings-for-other-languages-without-needing-a-compilation-step-pure-python-solutions", 
            "text": "cffi : Provides a way to call compiled C from Python without any compilation step (also compatible -- and fast -- with PyPy).    ctypes : Builtin to Python it's a way to call C code from Python without any compilation step (also compatible with PyPy but slower than cffi).", 
            "title": "Create bindings for other languages without needing a compilation step (pure-Python solutions)"
        }, 
        {
            "location": "/integrating_c_and_cpp/#wrap-cc-code-and-compile-it-to-create-bindings-for-existing-cc-libraries", 
            "text": "Cython : can compile Python code and mixed Cython/C/C++ code and can be used to create bindings for existing C/C++ libraries (the most \"Pythonic\" of the listed solutions).    SWIG : Provides a way to wrap C/C++ code and compile it creating bindings (not only for Python, but also a many other languages).    PyCXX : Provides a way to wrap C/C++ code and compile it creating bindings for Python.    Boost.Python : Provides a way to wrap C/C++ code and compile it creating bindings for Python.    SIP : used by PyQt to wrap Qt.    shiboken : Used by PySide to wrap Qt.", 
            "title": "Wrap C/C++ code and compile it to create bindings for existing C/C++ libraries."
        }
    ]
}